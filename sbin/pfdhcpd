#!/usr/bin/perl

=head1 NAME

pfdhcpd - PacketFence DHCP server and listener

=head1 SYNOPSIS

pfdhcpd

=cut

use warnings;
use strict;
use English qw( ‐no_match_vars ) ; # Avoids regex performance penalty
use File::Basename qw(basename);
use Getopt::Std;
use Log::Log4perl;
use Pod::Usage;
use POSIX qw(:signal_h setsid strftime);
use Sys::Hostname;
use IO::Interface::Simple;
use IO::Select;
use IO::Socket::INET;
use Net::DHCP::Packet;
use Net::DHCP::Constants;
use NetAddr::IP;
use Net::Ping;
use List::MoreUtils qw(uniq);
use Readonly;
use Digest::MD5;

BEGIN {
    # log4perl init
    use constant INSTALL_DIR => '/usr/local/pf';
    use lib INSTALL_DIR . "/lib";
    use pf::log(service => 'pfdhcplistener');
}

use pf::services::util;
use pf::config;
use pf::util;
use pf::iplog;
use pf::config::cached;
use pf::db;
use pf::inline::custom $INLINE_API_LEVEL;
use pf::locationlog;
use pf::lookup::node;
use pf::node;
use pf::os;
use pf::violation qw(violation_trigger);
use pf::ipset;
# Hum very strange lib !!!
use pf::stats;

Readonly my %MESSAGE_TYPE => (
    'DHCPDISCOVER' => 1,
    'DHCPOFFER' => 2,
    'DHCPREQUEST' => 3,
    'DHCPDECLINE' => 4,
    'DHCPACK' => 5,
    'DHCPNAK' => 6,
    'DHCPRELEASE' => 7,
    'DHCPINFORM' => 8,
);

Readonly my %MESSAGE_TYPE_TO_STRING => reverse %MESSAGE_TYPE;

my $sock_in;
my %listen_handler;
my %ethernet_inf;
my %lease;
my $ROGUE_DHCP_TRIGGER = '1100010';
my %rogue_servers;
my $is_inline_vlan;
my $accessControl;
my $interface_ip;
my $interface_vlan;
my @local_dhcp_servers;

# initialization
# --------------
# assign process name (see #1464)
$PROGRAM_NAME = basename($0);

my $logger = Log::Log4perl->get_logger( basename($PROGRAM_NAME) );

# init signal handlers
POSIX::sigaction(
    &POSIX::SIGHUP,
    POSIX::SigAction->new(
        'reload_config', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or $logger->logdie("basename($PROGRAM_NAME): could not set SIGHUP handler: $!");

POSIX::sigaction(
    &POSIX::SIGTERM,
    POSIX::SigAction->new(
        'normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or $logger->logdie("basename($PROGRAM_NAME): could not set SIGTERM handler: $!");

POSIX::sigaction(
    &POSIX::SIGINT,
    POSIX::SigAction->new(
        'normal_sighandler', POSIX::SigSet->new(), &POSIX::SA_NODEFER
    )
) or $logger->logdie("basename($PROGRAM_NAME): could not set SIGINT handler: $!");

our $RUNNING = 1;

my %args;
getopts( 'dshl:', \%args );

my $daemonize = $args{d};

my $stat = $args{s};

my $listener = $args{l};

pod2usage( -verbose => 1 ) if ( $args{h} );

# standard signals and daemonize
daemonize($PROGRAM_NAME) if ($daemonize);

END {
    deletepid($PROGRAM_NAME) unless $args{h};
}


my @ip_addr;


my $int;

# Adding to select:
my $read_set = new IO::Select();

my $keep_int;

=head2 reload_config

Reload the configuration and the sockets if the network interfaces changed.
Loaded at startup and when it receive a kill 1.

=cut

sub reload_config {
    $logger->warn("Reload dhcp config");
    pf::config::cached::ReloadConfigs();
    # Closing the current socket
    foreach $sock_in (@ip_addr) {
        $sock_in->close();
    }
    undef(@ip_addr);
    undef($keep_int);
    undef(%ethernet_inf);
    my @ints = uniq(@listen_ints,@dhcplistener_ints);
    foreach $int (@ints) {
        # If active/active setup only listen on these interfaces
        if (defined($Config{"interface $int"}{'haproxyip'})) {
            my @all_ifs = Net::Interface->interfaces();
            foreach my $inf (@all_ifs) {
                if ($inf->name eq $int) {
                    my @masks = $inf->netmask(AF_INET());
                    my @addresses = $inf->address(AF_INET());
                    for my $i (0 .. $#masks) {
                        if (inet_ntoa($addresses[$i]) eq $Config{"interface $int"}{'haproxyip'}) {
                            # Broadcast Socket
                            push @ip_addr, IO::Socket::INET->new(Type => SOCK_DGRAM, Reuse => 1, LocalPort => 67, Proto => 'udp', Broadcast => 1);
                            # Unicast Socket
                            my $if   = IO::Interface::Simple->new($int);
                            push @ip_addr, IO::Socket::INET->new(Type => SOCK_DGRAM, Reuse => 1, LocalPort => 67, LocalAddr => $if->address, Proto => 'udp');
                            # Only bind to a specific interface
                            $ip_addr[-1]->sockopt(25, $int);
                            $ip_addr[-2]->sockopt(25, $int);
                        }
                    }
                }
            }
        } else {
            # Broadcast Socket
            push @ip_addr, IO::Socket::INET->new(Type => SOCK_DGRAM, Reuse => 1, LocalPort => 67, Proto => 'udp', Broadcast => 1);
            # Unicast Socket
            my $if   = IO::Interface::Simple->new($int);
            push @ip_addr, IO::Socket::INET->new(Type => SOCK_DGRAM, Reuse => 1, LocalPort => 67, LocalAddr => $if->address, Proto => 'udp');
            # Only bind to a specific interface
            $ip_addr[-1]->sockopt(25, $int);
            $ip_addr[-2]->sockopt(25, $int);
        }
    }

    foreach $sock_in (@ip_addr) {
        $read_set->add($sock_in);
        $listen_handler{$sock_in} = \&dhcpd_handler;
        if (!defined($keep_int) || ($keep_int eq '')) {
            $keep_int = shift @ints;
            $ethernet_inf{$sock_in} = $keep_int;
        }
        else {
            $ethernet_inf{$sock_in} = $keep_int;
            $keep_int ='';
        }
    }
}


# Keep the last ip send by the server

foreach my $network ( keys %ConfigNetworks ) {
    $lease{$network} = $ConfigNetworks{$network}{'dhcp_start'};
}

reload_config;

# entering loop
while ($RUNNING) {
    my @select_set = $read_set->can_read;
    foreach my $server (@select_set) {
        my $handler = $listen_handler{$server};
        $handler->($server);
    }
}

sub dhcpd_handler {
    my ($sock_in) = @_;
    my $transaction = 0;            # report transaction number

    my $sock_answer;
    my $buf = undef;
    my $fromaddr;                        # address & port from which packet was received
    my $dhcpreq;
    my $net_addr;
    my %dhcp_config;

    #if is the interface where the dhcp traffic is coming
 
    my $if   = IO::Interface::Simple->new($ethernet_inf{$sock_in});

    $logger->debug("Incoming DHCP request on interface $ethernet_inf{$sock_in}");
    $logger->debug("Incoming DHCP request on ip ".$if->address);



    eval {                    # catch fatal errors

        # receive packet
        $fromaddr = $sock_in->recv($buf,4096) || $logger->warn("recv:$!");
        next if ($!);        # continue loop if an error occured
        $transaction++;                    # transaction counter
        my $peeraddr; 
        my $layer3 = 0;
        {
            use bytes;

            #Source ip address and port
            my ($port,$addr) = unpack_sockaddr_in($fromaddr);
            my $ipaddr = inet_ntoa($addr);

            $logger->debug("Got a packet tr=$transaction src=$ipaddr:$port length=".length($buf));
            #The answer is different if it is a layer 3 network
            #Suppose Layer 2 search for the direct network
            if ($ipaddr eq '0.0.0.0') {
                $peeraddr = '255.255.255.255';

                #Fetch the dhcp_config based on the network interface
                $net_addr = NetAddr::IP->new($if->address,$if->netmask);
                my $net = $net_addr->network;
                my $netAddress = $net->addr;
                %dhcp_config = %{$ConfigNetworks{$netAddress}} if(exists $ConfigNetworks{$netAddress} && defined $ConfigNetworks{$netAddress});
            }
            #Suppose Layer 3 search for the remote network
            else {
                #Fetch the dhcp_config based on the source ip address 
                $peeraddr = $ipaddr;
                foreach my $network ( keys %ConfigNetworks ) {
                    # shorter, more convenient local accessor
                    $net_addr = NetAddr::IP->new($network,$ConfigNetworks{$network}{'netmask'});
                    my $ip = new NetAddr::IP::Lite clean_ip($ipaddr);
                    if ($net_addr->contains($ip)) {
                        my $net = $net_addr->network;
                        my $netAddress = $net->addr;
                        %dhcp_config = %{$ConfigNetworks{$netAddress}} if(exists $ConfigNetworks{$netAddress} && defined $ConfigNetworks{$netAddress});
                        $layer3 = 1;
                        last;
                    }
                }
            }
        }
  
        my $dhcpreq = new Net::DHCP::Packet($buf);

        $logger->debug($dhcpreq->toString());

        # Add mac if not exist
        my $mac = clean_mac( substr( $dhcpreq->chaddr(), 0, 12 ) );
        if ( !node_exist($mac) ) {
            $logger->info("Unseen before node added: $mac");
            node_add_simple($mac);
        }
    
        # There is activity from that mac, call node wakeup
        node_mac_wakeup($mac);
    
        # Option 82 Relay Agent Information (RFC3046)
        if ( isenabled( $Config{'network'}{'dhcpoption82logger'} ) && defined( $dhcpreq->getOptionValue(DHO_DHCP_AGENT_OPTIONS()) ) ) {
            parse_dhcp_option82($dhcpreq);
        }
    
        # Proceed with the fingerpint

        # updating the node first
        # in case the fingerprint generates a violation and that autoreg uses fingerprint to auto-categorize nodes
        # see #1216 for details
        my %tmp;
        $tmp{'dhcp_fingerprint'} = defined($dhcpreq->getOptionValue(DHO_DHCP_PARAMETER_REQUEST_LIST() ) ) ? $dhcpreq->getOptionValue(DHO_DHCP_PARAMETER_REQUEST_LIST() ) : '';
        $tmp{'dhcp_fingerprint'} =~ s/\s/,/g;
        $tmp{'last_dhcp'} = mysql_date();
        $tmp{'computername'} = defined($dhcpreq->getOptionValue(DHO_HOST_NAME() )) ? $dhcpreq->getOptionValue(DHO_HOST_NAME() ) : '';
        my $vendor_id = defined($dhcpreq->getOptionValue(DHO_VENDOR_CLASS_IDENTIFIER() )) ? $dhcpreq->getOptionValue(DHO_VENDOR_CLASS_IDENTIFIER() ) : '';
        node_modify( $mac, %tmp ) ;
        my $fingerprint_data = process_fingerprint($dhcpreq);

        if (defined($stat)) {
            my $stats = pf::stats->new();
            my $md5 = Digest::MD5->new;
            $md5->add($tmp{'dhcp_fingerprint'},$vendor_id);
            $stats->stats_dhcp($mac,$tmp{'dhcp_fingerprint'},$vendor_id,$tmp{'computername'},$md5->hexdigest,$fingerprint_data);
        }

        my $modified_node_log_message = '';
        foreach my $node_key ( keys %tmp ) {
            $modified_node_log_message .= "$node_key = " . $tmp{$node_key} . ",";
        }
        chop($modified_node_log_message);

        $logger->info("$mac requested an IP. "
            . ( defined($fingerprint_data) ? "DHCP Fingerprint: $fingerprint_data. " : "Unknown DHCP fingerprint. " )
            . "Modified node with $modified_node_log_message"
        );

        #Fetch the request type in the dhcp packet
        my $messagetype = $dhcpreq->getOptionValue(DHO_DHCP_MESSAGE_TYPE());

        if ($messagetype eq DHCPDISCOVER()) {
            do_discover($dhcpreq,$peeraddr,\$if,\%dhcp_config,\$net_addr,$layer3);
        } elsif ($messagetype eq DHCPREQUEST()) {
            do_request($dhcpreq,$peeraddr,\$if,\%dhcp_config,\$net_addr,$layer3);
        } elsif ($messagetype eq DHCPINFORM()) {
            do_inform($dhcpreq,$peeraddr,\$if,\%dhcp_config,\$net_addr,$layer3);
        } elsif ($messagetype eq DHCPRELEASE()) {
            parse_dhcp_release($dhcpreq,\$if);
        } else {
            $logger->warn("Packet dropped");
            # bad messagetype, we drop it
        }
    };
    # end of 'eval' blocks

    if ($@) {
        $logger->warn("Caught error in main loop:$@");
    }
       
}

sub do_discover {
    my ($dhcpreq, $peeraddr, $ip_src,$dhcp_config,$net_addr,$layer3) = @_;
    # $dhcpreq is the dhcp request object
    # $peeraddr is the ip source of the packet
    # $ip_src is the network interface where the packet is coming
    # $dhcp_config is the dhcp config for this network from networks.conf
    # $net_addr is a NetAddr::IP object of the dhcp zone

    # If we find a dhcp configuration then we have to answer
    if ($dhcp_config->{'netmask'}) {
        my $net = $$net_addr->network;

        # Calculate the ip address
        my $ip = calc_ip($dhcp_config,$net,$dhcpreq->chaddr);

        # Need the broadcast address
        my $broadcast = $$net_addr->broadcast();

        # Create the dhcp offer
        my $dhcpresp = new Net::DHCP::Packet(
            Comment => $dhcpreq->comment(),
            Op => BOOTREPLY(),
            Hops => $dhcpreq->hops(),
            Xid => $dhcpreq->xid(),
            Flags => $dhcpreq->flags(),
            Ciaddr => $dhcpreq->ciaddr(),
            Yiaddr => $ip,
            Siaddr => $dhcpreq->siaddr(),
            Giaddr => $dhcpreq->giaddr(),
            Chaddr => $dhcpreq->chaddr(),
            DHO_DHCP_MESSAGE_TYPE() => DHCPOFFER()
            );
            $dhcpresp->addOptionValue(DHO_DHCP_SERVER_IDENTIFIER() , $$ip_src->address);
            $dhcpresp->addOptionValue(DHO_DHCP_LEASE_TIME() , $dhcp_config->{'dhcp_default_lease_time'});
            $dhcpresp->addOptionValue(DHO_SUBNET_MASK() , $dhcp_config->{'netmask'});
            $dhcpresp->addOptionValue(DHO_ROUTERS() , $dhcp_config->{'gateway'});
            $dhcpresp->addOptionValue(DHO_DOMAIN_NAME_SERVERS() , $dhcp_config->{'dns'});
            $dhcpresp->addOptionValue(DHO_DOMAIN_NAME() , $dhcp_config->{'domain-name'});
            $dhcpresp->addOptionValue(DHO_BROADCAST_ADDRESS() , $broadcast->addr);
            $dhcpresp->addOptionValue(DHO_DHCP_RENEWAL_TIME() , $dhcp_config->{'dhcp_default_lease_time'}/2 );
            $dhcpresp->addOptionValue(DHO_DHCP_REBINDING_TIME() , $dhcp_config->{'dhcp_default_lease_time'} - 5 );

        $logger->debug($dhcpresp->toString());
        if(!defined($listener)) {
            # Parse the dhcp offer
            parse_dhcp_offer($dhcpresp,$ip_src);

            my $peer = "$peeraddr:68";
            $peer = "$peeraddr:67" if ($layer3);
            my $mac = clean_mac( substr( $dhcpreq->chaddr(), 0, 12 ));
            # Create the socket to answer to the client
            my $sock_in = IO::Socket::INET->new(Type => SOCK_DGRAM, Reuse => 1, LocalPort => 67, LocalAddr => $$ip_src->address, Proto => 'udp', Broadcast => 1, PeerAddr => "$peer");
            # Send the packet to the network
            $sock_in->send($dhcpresp->serialize());
            shutdown($sock_in, 2);
        }
    }
    # Parse the dhcp discover in all case
    parse_dhcp_discover($dhcpreq,$ip_src);
}

sub do_request {
    my ($dhcpreq,$peeraddr,$ip_src,$dhcp_config,$net_addr,$layer3) = @_;
    # $dhcpreq is the dhcp request object
    # $peeraddr is the ip source of the packet
    # $ip_src is the network interface where the packet is coming
    # $dhcp_config is the dhcp config for this network from networks.conf
    # $net_addr is a NetAddr::IP object of the dhcp zone

    # If we find a dhcp configuration then we have to answer
    if ($dhcp_config->{'netmask'}) {
        my $dhcpresp;
        my $net = $$net_addr->network;

        # Calculate the ip address
        my $ip = calc_ip($dhcp_config,$net,$dhcpreq->chaddr,$dhcpreq->ciaddr);
        # File the lease hash

        # Need the broadcast address
        my $broadcast = $$net_addr->broadcast();

        # compare calculated address with requested address
        if ( ( defined($dhcpreq->getOptionValue(DHO_DHCP_REQUESTED_ADDRESS())) && ($ip eq $dhcpreq->getOptionValue(DHO_DHCP_REQUESTED_ADDRESS()))) || $dhcpreq->ciaddr !~ /^0\.0\.0\.0$/)   {
            # address is correct, we send an ACK

            # Send to the specific ip (iscdhcp send to the ip/mac)
            #$peeraddr = $ip;

            $dhcpresp = new Net::DHCP::Packet(
                Comment => $dhcpreq->comment(),
                Op => BOOTREPLY(),
                Hops => $dhcpreq->hops(),
                Xid => $dhcpreq->xid(),
                Flags => $dhcpreq->flags(),
                Ciaddr => $dhcpreq->ciaddr(),
                Yiaddr => $ip,
                Siaddr => $dhcpreq->siaddr(),
                Giaddr => $dhcpreq->giaddr(),
                Chaddr => $dhcpreq->chaddr(),
                DHO_DHCP_MESSAGE_TYPE() => DHCPACK()
                );
                $dhcpresp->addOptionValue(DHO_DHCP_SERVER_IDENTIFIER() , $$ip_src->address);
                $dhcpresp->addOptionValue(DHO_DHCP_LEASE_TIME() , $dhcp_config->{'dhcp_default_lease_time'});
                $dhcpresp->addOptionValue(DHO_SUBNET_MASK() , $dhcp_config->{'netmask'});
                $dhcpresp->addOptionValue(DHO_ROUTERS() , $dhcp_config->{'gateway'});
                $dhcpresp->addOptionValue(DHO_DOMAIN_NAME_SERVERS() , $dhcp_config->{'dns'});
                $dhcpresp->addOptionValue(DHO_DOMAIN_NAME() , $dhcp_config->{'domain-name'});
                $dhcpresp->addOptionValue(DHO_BROADCAST_ADDRESS() , $broadcast->addr);
                $dhcpresp->addOptionValue(DHO_DHCP_RENEWAL_TIME() , $dhcp_config->{'dhcp_default_lease_time'} / 2);
                $dhcpresp->addOptionValue(DHO_DHCP_REBINDING_TIME() , $dhcp_config->{'dhcp_default_lease_time'} - 5);

        } else {
            # bad request, we send a NAK
            $dhcpresp = new Net::DHCP::Packet(
                Comment => $dhcpreq->comment(),
                Op => BOOTREPLY(),
                Hops => $dhcpreq->hops(),
                Xid => $dhcpreq->xid(),
                Flags => $dhcpreq->flags(),
                Ciaddr => $dhcpreq->ciaddr(),
                Yiaddr => "0.0.0.0",
                Siaddr => $dhcpreq->siaddr(),
                Giaddr => $dhcpreq->giaddr(),
                Chaddr => $dhcpreq->chaddr(),
                DHO_DHCP_MESSAGE_TYPE() => DHCPNAK(),
                DHO_DHCP_MESSAGE(), "Bad request...",
            );
        }

        $logger->debug("Sending ACK/NAK tr=$dhcpresp->comment()");
        $logger->debug($dhcpreq->toString());
        $logger->debug($dhcpresp->toString());
        $logger->debug($peeraddr);
        if (!defined($listener)) {
            my $sock_in;
            if ($layer3) {
                $sock_in = IO::Socket::INET->new(Type => SOCK_DGRAM, Reuse => 1, LocalPort => 67, LocalAddr => $$ip_src->address, Proto => 'udp', ,PeerAddr => "$peeraddr:67");
               # Send the packet to the network
               $sock_in->send($dhcpresp->serialize());
               shutdown($sock_in, 2);
            } else {
                $sock_in = IO::Socket::INET->new(Type => SOCK_DGRAM, Reuse => 1, LocalPort => 67, LocalAddr => $$ip_src->address, Proto => 'udp', Broadcast => 1,PeerAddr => "$peeraddr:68");
                # Send the packet to the network
                $sock_in->send($dhcpresp->serialize());
                shutdown($sock_in, 2);
                # Send a unicast packet
                $sock_in = IO::Socket::INET->new(Type => SOCK_DGRAM, Reuse => 1, LocalPort => 67, LocalAddr => $$ip_src->address, Proto => 'udp', PeerAddr => "$ip:68");
                # Send the packet to the network
                $sock_in->send($dhcpresp->serialize());
                shutdown($sock_in, 2);
           }
        }
    } else {
        # No dhcp zone then we parse the dhcp request (Listener)
        parse_dhcp_request($dhcpreq,$ip_src);
    }
}

sub calc_ip {
    my ($dhcp_config, $net_addr,$mac,$host) = @_;
    my $ip_last;
    $mac = clean_mac( substr( $mac, 0, 12 ) );
    my $count = 1;
    my $node_iplog_info = iplog_view_open_mac($mac);

    my $ip = new NetAddr::IP::Lite clean_ip($node_iplog_info->{'ip'}) if defined($node_iplog_info->{'ip'});
    # Device still exist in iplog, resend the same ip address
    if (defined($node_iplog_info->{'ip'}) && $net_addr->contains($ip) ) {
        update_iplog( $mac, $node_iplog_info->{'ip'}, $dhcp_config->{'dhcp_max_lease_time'} );
        return $node_iplog_info->{'ip'};
    # Send a new address + 1 or the starting ip address of the dhcp zone
    } elsif (defined($lease{$net_addr->addr})) {
        $ip_last = NetAddr::IP->new($lease{$net_addr->addr},$dhcp_config->{'netmask'});
        my $broadcast = $ip_last->broadcast();
        my $network = $ip_last->network();
        while ($count) {
            $ip_last = $ip_last + 1;
            my $mac2 = iplog_view_open_ip($ip_last->addr);
            if (!defined($mac2)) {
                $count = 0;
            } else {
                $ip_last = $ip_last + 1;
                if ($ip_last->addr eq $broadcast->addr()) {
                    $ip_last = $ip_last + 2;
                } elsif ($ip_last->addr eq $network->addr()) {
                    $ip_last = $ip_last + 1;
                }
            }
            if ($ip_last->addr eq $lease{$net_addr->addr}) {
                $logger->warn("We tested all the ip of the range, wait the dhcp_lease_time and retry");
                sleep($dhcp_config->{'dhcp_max_lease_time'});
            }
        }
    } else {
        $ip_last = NetAddr::IP->new($dhcp_config->{'dhcp_start'},$dhcp_config->{'netmask'});
    }
    # Keep the last assign address
    $lease{$net_addr->addr} = $ip_last->addr;
    update_iplog( $mac, $ip_last->addr, $dhcp_config->{'dhcp_max_lease_time'} );
    return $ip_last->addr;
}


=item get_local_dhcp_servers

Return a list of all dhcp servers IP that could be running locally.

Caches results on first run then returns from cache.

=cut
sub get_local_dhcp_servers {

    # return from cache
    return @local_dhcp_servers if (@local_dhcp_servers);

    # look them up, fill cache and return result
    foreach my $network (keys %ConfigNetworks) {

        push @local_dhcp_servers, $ConfigNetworks{$network}{'gateway'}
            if ($ConfigNetworks{$network}{'dhcpd'} eq 'enabled');
    }
    return @local_dhcp_servers;
}

=item process_fingerprint

=over

=item Calls violation_trigger for every matching DHCP fingerprint type and class.

=item Logs unknown fingerprints

=item Returns a string that identifies OS id and name

=back

=cut
sub process_fingerprint {
    my ($dhcp) = @_;

    my $dhcp_fingerprint = $dhcp->getOptionValue(DHO_DHCP_PARAMETER_REQUEST_LIST());
    $dhcp_fingerprint =~ s/\s/,/g;
    my $chaddr = clean_mac( substr( $dhcp->chaddr(), 0, 12 ) );
    my $fingerprint_data;

    return if (!defined($dhcp_fingerprint) || $dhcp_fingerprint eq "");

    my @fingerprint_info = dhcp_fingerprint_view($dhcp_fingerprint);
    if ( scalar(@fingerprint_info) && ( ref( $fingerprint_info[0] ) eq 'HASH' ) ) {

        # precise fingerprint
        $fingerprint_data = "OS::".$fingerprint_info[0]->{'id'}." (".$fingerprint_info[0]->{'os'}.")";
        $logger->debug("$chaddr sending $fingerprint_data trigger");
        violation_trigger( $chaddr, $fingerprint_info[0]->{'id'}, "OS" );

        # class fingerprints
        foreach my $class_trigger (@fingerprint_info) {
            my $class_data = "OS::".$class_trigger->{'classid'}." (".$class_trigger->{'class'}.")";
            $logger->debug("$chaddr sending $class_data trigger");
            violation_trigger( $chaddr, $class_trigger->{'classid'}, "OS" );
        }

    } else {
        my $dhcp_type = dhcp_message_type_to_string($dhcp->getOptionValue(DHO_DHCP_MESSAGE_TYPE()));
        $logger->info("Unknown DHCP fingerprint: $dhcp_fingerprint (DHCP Message Type: $dhcp_type)");
    }

    return $fingerprint_data;
}

=item parse_dhcp_option82

Option 82 is Relay Agent Information. Defined in RFC 3046.

=cut
sub parse_dhcp_option82 {
    my ($dhcp) = @_;

    # slicing the hash to retrive the stuff we are interested in
    my ($switch, $vlan, $mod, $port)  = @{$dhcp->getOptionValue(DHO_DHCP_AGENT_OPTIONS())}{'switch', 'vlan', 'module', 'port'};
    if ( defined($switch) && defined($vlan) && defined($mod) && defined($port) ) {

        # TODO port should be translated into ifIndex
        # FIXME option82 stuff needs to be re-validated (#1340)
        locationlog_insert_closed($switch, $mod . '/' . $port, $vlan, clean_mac( substr( $dhcp->chaddr(), 0, 12 ) ), '');
    }
}

sub update_iplog {
    my ( $srcmac, $srcip, $lease_length ) = @_;
    $logger->debug("$srcip && $srcmac");

    # return if MAC or IP is not valid
    if ( !valid_mac($srcmac) || !valid_ip($srcip) ) {
        $logger->error("invalid MAC or IP: $srcmac $srcip");
        return;
    }

    my $oldmac = ip2mac($srcip);
    my $oldip  = mac2ip($srcmac);

    if ( $oldip && $oldip ne $srcip ) {
        my $view_mac = node_view($srcmac);
        if ($view_mac->{'last_connection_type'} eq $connection_type_to_str{$INLINE}) {
            my $technique = $accessControl->{_technique};
            if ($IPSET_VERSION != 0) {
                pf::ipset::update_node($oldip, $srcip, $srcmac);
            }
            #Problem with instanciate the technique Issue ID:1585
            #$technique->update_node($oldip, $srcip, $srcmac);
        }
        $logger->info(
            "oldip ($oldip) and newip ($srcip) are different for $srcmac - closing iplog entry"
        );
        iplog_close_now($oldip);
    }
    iplog_open( $srcmac, $srcip, $lease_length );
}

=item rogue_dhcp_handling

Requires DHCP Server IP

Optional but very useful DHCP Server MAC

=cut
sub rogue_dhcp_handling {
    my ($dhcp_srv_ip, $dhcp_srv_mac, $offered_ip, $client_mac, $relay_ip, $if) = @_;

    return if (isdisabled($Config{'network'}{'rogue_dhcp_detection'}));

    # if server ip is empty, it means that the client is asking for it's old IP and this should be legit
    if (!defined($dhcp_srv_ip)) {
        $logger->debug(
            "received empty DHCP Server IP in rogue detection. " .
            "Offered IP: " . ( defined($offered_ip) ? $offered_ip : 'unknown' )
        );
        return;
    }

    # ignore local DHCP servers
    return if ( grep({$_ eq $dhcp_srv_ip} get_local_dhcp_servers()) );

    # ignore whitelisted DHCP servers
    return if ( grep({$_ eq $dhcp_srv_ip} split(/\s*,\s*/, $Config{'general'}{'dhcpservers'})) );

    my $rogue_offer = sprintf( "%s: %15s to %s on interface %s", mysql_date(), $offered_ip, $client_mac,$$if->name );
    if (defined($relay_ip) && $relay_ip !~ /^0\.0\.0\.0$/) {
        $rogue_offer .= " received via relay $relay_ip";
    }
    $rogue_offer .= "\n";
    push @{ $rogue_servers{$dhcp_srv_ip} }, $rogue_offer;

    # if I have a MAC use it, otherwise look it up
    $dhcp_srv_mac = ip2mac($dhcp_srv_ip) if (!defined($dhcp_srv_mac));
    if ($dhcp_srv_mac) {
        violation_trigger( $dhcp_srv_mac, $ROGUE_DHCP_TRIGGER, 'INTERNAL' );
    } else {
        $logger->info("Unable to find MAC based on IP $dhcp_srv_ip for rogue DHCP server");
        $dhcp_srv_mac = 'unknown';
    }

    $logger->warn("$dhcp_srv_ip ($dhcp_srv_mac) was detected offering $offered_ip to $client_mac on ".$$if->name);
    if (scalar( @{ $rogue_servers{$dhcp_srv_ip} } ) == $Config{'network'}{'rogueinterval'} ) {
        my %rogue_message;
        $rogue_message{'subject'} = "ROGUE DHCP SERVER DETECTED AT $dhcp_srv_ip ($dhcp_srv_mac) ON ".$$if->name."\n";
        $rogue_message{'message'} = '';
        if ($dhcp_srv_mac ne 'unknown') {
            $rogue_message{'message'} .= pf::lookup::node::lookup_node($dhcp_srv_mac) . "\n";
        }
        $rogue_message{'message'} .= "Detected Offers\n---------------\n";
        while ( @{ $rogue_servers{$dhcp_srv_ip} } ) {
            $rogue_message{'message'} .= pop( @{ $rogue_servers{$dhcp_srv_ip} } );
        }
        $rogue_message{'message'} .=
            "\n\nIf this DHCP Server is legitimate, make sure to add it to the dhcpservers list under General.\n"
        ;
        pfmailer(%rogue_message);
    }
}

=item parse_dhcp_discover

=cut
sub parse_dhcp_discover {
    my ($dhcp,$if) = @_;
    $logger->debug("DHCPDISCOVER from ". clean_mac( substr( $dhcp->chaddr(), 0, 12 ) ));
}

=item parse_dhcp_offer

=cut
sub parse_dhcp_offer {
    my ($dhcp,$if) = @_;

    if ($dhcp->yiaddr() =~ /^0\.0\.0\.0$/) {
        $logger->warn("DHCPOFFER invalid IP in DHCP's yiaddr for ". clean_mac( substr( $dhcp->chaddr(), 0, 12 ) ));
        return;
    }

    $logger->info("DHCPOFFER from ".$$if->address." to host ". clean_mac( substr( $dhcp->chaddr(), 0, 12 ) )." (".$dhcp->yiaddr().")");

    rogue_dhcp_handling($$if->address, undef, $dhcp->yiaddr(), clean_mac( substr( $dhcp->chaddr(), 0, 12 ) ), $dhcp->giaddr(),$if);
}

=item parse_dhcp_request

=cut
sub parse_dhcp_request {
    my ($dhcp,$if) = @_;
    $logger->debug("DHCPREQUEST from ". clean_mac( substr( $dhcp->chaddr(), 0, 12 ) ));

    my $lease_length = $dhcp->getOptionValue(DHO_DHCP_LEASE_TIME());
    my $client_ip = $dhcp->getOptionValue(DHO_DHCP_REQUESTED_ADDRESS());
    if (defined($client_ip) && $client_ip !~ /^0\.0\.0\.0$/) {
        $logger->info(
            "DHCPREQUEST from ". clean_mac( substr( $dhcp->chaddr(), 0, 12 ) )." (".$client_ip.")"
            . ( defined($lease_length) ? " with lease of $lease_length seconds" : "")
        );
        update_iplog( clean_mac( substr( $dhcp->chaddr(), 0, 12 ) ), $client_ip, $lease_length );
    }

    # As per RFC2131 in a DHCPREQUEST if ciaddr is set and we broadcast, we are in re-binding state
    # in which case we are not interested in detecting rogue DHCP
    if ($dhcp->ciaddr() =~ /^0\.0\.0\.0$/) {
        rogue_dhcp_handling($dhcp->getOptionValue(DHO_DHCP_SERVER_IDENTIFIER()), undef, $client_ip, clean_mac( substr( $dhcp->chaddr(), 0, 12 ) ), $dhcp->giaddr(),$if);
    }

    if ($is_inline_vlan) {
        locationlog_synchronize($interface_ip, $NO_PORT, $interface_vlan, clean_mac( substr( $dhcp->chaddr(), 0, 12 ) ), $NO_VOIP, $INLINE);
        $accessControl->performInlineEnforcement(clean_mac( substr( $dhcp->chaddr(), 0, 12 ) ));
    }
}


=item parse_dhcp_ack

=cut
sub parse_dhcp_ack {
    my ($dhcp,$if) = @_;

    my $s_ip = $$if->address;
    my $s_mac = $$if->hwaddr;

    my $lease_length = $dhcp->getOptionValue(DHO_DHCP_LEASE_TIME());

    if ($dhcp->yiaddr() !~ /^0\.0\.0\.0$/) {

        $logger->info(
            "DHCPACK from $s_ip ($s_mac) to host ". clean_mac( substr( $dhcp->chaddr(), 0, 12 ) )." (". $dhcp->yiaddr().")"
            . ( defined($lease_length) ? " for $lease_length seconds" : "" )
        );
        update_iplog( clean_mac( substr( $dhcp->chaddr(), 0, 12 ) ), $dhcp->yiaddr(), $lease_length );

    } elsif ($dhcp->ciaddr() !~ /^0\.0\.0\.0$/) {

        $logger->info(
            "DHCPACK CIADDR from $s_ip ($s_mac) to host ".clean_mac( substr( $dhcp->chaddr(), 0, 12 ) )." (".$dhcp->ciaddr().")"
            . ( defined($lease_length) ? " for $lease_length seconds" : "")
        );
        update_iplog( clean_mac( substr( $dhcp->chaddr(), 0, 12 ) ), $dhcp->ciaddr(), $lease_length );

    } else {
        $logger->warn(
            "invalid DHCPACK from $s_ip ($s_mac) to host ".clean_mac( substr( $dhcp->chaddr(), 0, 12 ) )." [".$dhcp->yiaddr()." - ".$dhcp->ciaddr()."]"
        );
    }
}

=item parse_dhcp_release

=cut
sub parse_dhcp_release {
    my ($dhcp,$if) = @_;
    $logger->debug("DHCPRELEASE from ". clean_mac( substr( $dhcp->chaddr(), 0, 12 ) )." (".$dhcp->ciaddr().")");
    iplog_close($dhcp->ciaddr());
}

=item do_inform

=cut
sub do_inform {
 my ($dhcpreq,$peeraddr,$ip_src,$dhcp_config,$net_addr) = @_;
    # $dhcpreq is the dhcp request object
    # $peeraddr is the ip source of the packet
    # $ip_src is the network interface where the packet is coming
    # $dhcp_config is the dhcp config for this network from networks.conf
    # $net_addr is a NetAddr::IP object of the dhcp zone

    # If we find a dhcp configuration then we have to answer
    if ($dhcp_config->{'netmask'}) {
        my $dhcpresp;
        my $net = $$net_addr->network;

        # Calculate the ip address

        # Need the broadcast address
        my $broadcast = $$net_addr->broadcast();
        my $ip = $dhcpreq->ciaddr;

        $dhcpresp = new Net::DHCP::Packet(
            Comment => $dhcpreq->comment(),
            Op => BOOTREPLY(),
            Hops => $dhcpreq->hops(),
            Xid => $dhcpreq->xid(),
            Flags => $dhcpreq->flags(),
            Ciaddr => $dhcpreq->ciaddr(),
            Yiaddr => $dhcpreq->ciaddr(),
            Siaddr => $$ip_src->address,
            Giaddr => $dhcpreq->giaddr(),
            Chaddr => $dhcpreq->chaddr(),
            DHO_DHCP_MESSAGE_TYPE() => DHCPACK()
            );
            $dhcpresp->addOptionValue(DHO_DHCP_SERVER_IDENTIFIER() , $$ip_src->address);
            $dhcpresp->addOptionValue(DHO_SUBNET_MASK() , $dhcp_config->{'netmask'});
            $dhcpresp->addOptionValue(DHO_ROUTERS() , $dhcp_config->{'gateway'});
            $dhcpresp->addOptionValue(DHO_DOMAIN_NAME_SERVERS() , $dhcp_config->{'dns'});
            $dhcpresp->addOptionValue(DHO_DOMAIN_NAME() , $dhcp_config->{'domain-name'});
            $dhcpresp->addOptionValue(DHO_BROADCAST_ADDRESS() , $broadcast->addr);

        $logger->debug("Sending ACK/NAK tr=$dhcpresp->comment()");
        $logger->debug($dhcpreq->toString());
        $logger->debug($dhcpresp->toString());

        if (!defined($listener)) {
            # Send Unicast
            my $sock_in = IO::Socket::INET->new(Type => SOCK_DGRAM, Reuse => 1, LocalPort => 67, LocalAddr => $$ip_src->address, Proto => 'udp', PeerAddr => "$ip:68");

            # Send the packet to the network
            $sock_in->send($dhcpresp->serialize());
            shutdown($sock_in, 2);
        }
    }
    #update_iplog( clean_mac( substr( $dhcpreq->chaddr(), 0, 12 ) ), $dhcpreq->ciaddr(), $dhcp_config->{'dhcp_max_lease_time'} + 5);
    $logger->warn("DHCPINFORM from ".clean_mac( substr( $dhcpreq->chaddr(), 0, 12 ) )." (".$dhcpreq->ciaddr().")");
}

sub dhcp_message_type_to_string {
    my ($id) = @_;

    return $MESSAGE_TYPE_TO_STRING{$id};
}

sub normal_sighandler {
    $RUNNING = 0;
    $logger->debug( "$PROGRAM_NAME: caught SIG" . $_[0] . " - terminating" );
}

=back

=head1 BUGS AND LIMITATIONS

Probably

=head1 COPYRIGHT

Copyright (C) 2007-2014 Inverse inc.

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
USA.

=cut

